<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Topology</title>
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    <script type="text/javascript" src="{{ url_for('static', filename='js/vis-network.min.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/vis-network.min.css') }}">
    <style>
        .areaLegend{
            margin-bottom: 5px;
            cursor: pointer;
        }
        .colorBox{
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div style="display: flex; flex-direction: row; justify-content:start; gap: 10px; align-items: start;">
        <div id="legend" style="padding: 10px; font-family: Arial, sans-serif; border: 2px solid black; width: fit-content;"></div>
        <div id="external-routes" style="padding-left: 10px; padding-right: 10px; font-family: Arial, sans-serif; width: fit-content;"></div>
    </div>
    <div id="network" style="width: 100%; height: 400px; margin-top: 50px;"></div>
    <div id="info"></div>

    <script type="text/javascript">
        let networkData = {{ data|safe }};
        console.log(networkData);

        const colors = [
            "#0000FF",
            "#FF0000",
            "#00FF00",
            "#FFFF00",
            "#00FFFF",
            "#FF00FF",
            "#FFA500",
            "#800080" 
        ];

        let nodes = [];
        let edges = [];

        let routerImage = '../static/images/router.png';
        let switchImage = '../static/images/switch.png';
        
        networkData.areas.forEach(function(area, index) {
            const areaColor = colors[index % colors.length];
        
            const legendDiv = document.getElementById('legend');
            const areaLegend = document.createElement('div');
            areaLegend.className = 'areaLegend';
        
            const colorBox = document.createElement('span');
            colorBox.className = 'colorBox';
            colorBox.style.backgroundColor = areaColor;
        
            const areaName = document.createElement('span');
            areaName.textContent = "Area " + area.area_id;
        
            areaLegend.appendChild(colorBox);
            areaLegend.appendChild(areaName);
            
            areaLegend.addEventListener('click', () => {
                const infoDiv = document.getElementById('info');
                infoDiv.innerHTML = ""; 
        
                if (area.ospf_inter_area_routes.length > 0) {
                    const interAreaTitle = document.createElement('h3');
                    interAreaTitle.textContent = 'Rotte Inter-Area OSPF:';
                    infoDiv.appendChild(interAreaTitle);
            
                    const interAreaList = document.createElement('ul');
                    area.ospf_inter_area_routes.forEach(route => {
                        const listItem = document.createElement('li');
                        listItem.textContent = `Dest: ${route.ip}/${route.mask} via ${route.via}`;
                        interAreaList.appendChild(listItem);
                    });
                    infoDiv.appendChild(interAreaList);
                } else {
                    infoDiv.innerHTML += "<p>Nessuna rotta inter-area OSPF</p>";
                }
            
                if (area.paths_to_asbrs.length > 0) {
                    const asbrTitle = document.createElement('h3');
                    asbrTitle.textContent = "Percorsi verso ASBR:";
                    infoDiv.appendChild(asbrTitle);
            
                    const asbrList = document.createElement('ul');
                    area.paths_to_asbrs.forEach(path => {
                        const listItem = document.createElement('li');
                        listItem.textContent = `ASBR: ${path.asbr} via ${path.via} (metrica: ${path.metric})`;
                        asbrList.appendChild(listItem);
                    });
                    infoDiv.appendChild(asbrList);
                } else {
                    infoDiv.innerHTML += "<p>Nessun percorso verso ASBR</p>";
                }
            });
        
            legendDiv.appendChild(areaLegend);

            area.nodes.forEach(function(node) {
                if (!nodes.some(n => n.id === node)) {
                    nodes.push({
                        id: node, 
                        label: node, 
                        image: routerImage,
                        shape: 'image',    
                        size: 30,          
                        borderWidth: 2
                    });
                }
            });

            area.links.forEach(function(link) {
                let endpoints = link.endpoints;
                
                if (endpoints.length >= 3) {
                    let switchId = "switch_" + link.id;
                    
                    if (!nodes.some(n => n.id === switchId)) {
                        nodes.push({
                            id: switchId, 
                            label: "Switch " + link.id + " / " + find_subnet_length(link.mask),
                            image: switchImage,
                            shape: 'image',
                            size: 30,
                            borderWidth: 2
                        });
                    }

                    for (let i = 0; i < endpoints.length; i++) {
                        edges.push({
                            from: switchId,
                            to: endpoints[i],
                            label: link.id + " / " + find_subnet_length(link.mask),
                            title: link.type + " - " + link.metric,
                            color: { color: areaColor }
                        });
                    }
                } else {
                    let endpoint1 = endpoints[0];
                    let endpoint2 = endpoints[1];
                    edges.push({ 
                        from: endpoint1, 
                        to: endpoint2, 
                        label: link.id + " / " + find_subnet_length(link.mask), 
                        title: link.type + " - " + link.metric,
                        arrows: 'none',
                        color: { color: areaColor }
                    });
                }
            });
        });

        const externalRoutesDiv = document.getElementById('external-routes');
        if (networkData.external_routes && networkData.external_routes.length > 0) {
            const externalRoutesTitle = document.createElement('h3');
            externalRoutesTitle.textContent = "Rotte Esterne:";
            externalRoutesDiv.appendChild(externalRoutesTitle);
        
            const externalRoutesList = document.createElement('ul');
            networkData.external_routes.forEach(route => {
                const listItem = document.createElement('li');
                listItem.textContent = `Dest: ${route.ip}/${route.mask} via ${route.via} (metrica: ${route.metric}, tipo: ${route.metric_type})`;
                externalRoutesList.appendChild(listItem);
            });
            externalRoutesDiv.appendChild(externalRoutesList);
        } else {
            externalRoutesDiv.innerHTML += "<p>Nessuna rotta esterna</p>";
        }

        let options = {
            nodes: {
                shape: 'image',
                size: 30,
                font: { size: 14 }
            },
            edges: {
                smooth: false,
                font: { size: 10, align: 'top' }
            },
            layout: {
                randomSeed: 2
            },    
            interaction: {
                hover: true,
                zoomView: false
            },
            physics: {
                enabled: false
            }
        };

        let container = document.getElementById('network');
        let data = { nodes: nodes, edges: edges };
        let network = new vis.Network(container, data, options);

        network.on("hoverNode", () => { container.style.cursor = "pointer"; });
        
        network.on("blurNode", () => { container.style.cursor = "default"; });
        
        network.on("hoverEdge", () => { container.style.cursor = "pointer"; });
        
        network.on("blurEdge", () => { container.style.cursor = "default"; });

        network.on("click", function (params) {
            if (params.edges.length > 0 && params.nodes.length === 0) {
                let edgeId = params.edges[0];

                let targetEdge = edges.find(e => e.id === edgeId);
                
                let edge = null;
                for (let area of networkData.areas) {
                    edge = area.links.find(link => link.id === targetEdge.label.split(' /')[0]);
                    if (edge) break;
                }
        
                if (!edge) {
                    console.warn("Nessun link trovato con label:", targetEdge.label);
                    return;
                }

                let infoDiv = document.getElementById('info');
                infoDiv.innerHTML = `<h3>Dettagli Link</h3>
                    <p><strong>IP:</strong> ${edge.id}</p>
                    <p><strong>Mask:</strong> ${edge.mask}</p>
                    <p><strong>Tipo:</strong> ${edge.type }</p>
                    <p><strong>Metric:</strong> ${edge.metric}</p>
                    <p><strong>Designated Router:</strong> ${edge.dr}</p>
                    <p><strong>Backup Designated Router:</strong> ${edge.bdr}</p>`;
        
                if (edge.endpoints) {
                    infoDiv.innerHTML += `<p><strong>Endpoints:</strong> ${edge.endpoints.join(", ")}</p>`;
                } else {
                    infoDiv.innerHTML += `<p>Endpoints non disponibili</p>`;
                }
            }
        });        

        function find_subnet_length(mask) {
            const octets = mask.split('.');

            let bitCount = 0;

            for (let i = 0; i < octets.length; i++) {
                let binaryOctet = parseInt(octets[i]).toString(2).padStart(8, '0');
                bitCount += binaryOctet.split('1').length - 1;
            }

            return bitCount;
        }
    </script>
</body>
</html>
